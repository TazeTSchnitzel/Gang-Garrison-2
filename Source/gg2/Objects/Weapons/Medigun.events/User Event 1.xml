<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="OTHER" id="11">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">{
    if(!instance_exists(healTarget) and readyToShoot) {
        var bestTarget, bestTargetDist;
        bestTarget=noone;
        bestTargetDist=maxHealDistance;

        // Make list of Characters and Sentries so we can look at both
        var list, i, target;
        list = ds_list_create();
        with (Character)
            ds_list_add(list, id);
        with (Sentry)
            ds_list_add(list, id);
        for (i = 0; i &lt; ds_list_size(list); i += 1) {
            target = ds_list_find_value(list, i);
            if(target != owner and target.team == owner.team) {
                if(point_distance(target.x,target.y,x,y)&lt;=bestTargetDist) {
                    if(collision_line(x, y, x+lengthdir_x(maxHealDistance, owner.aimDirection), y+lengthdir_y(maxHealDistance, owner.aimDirection), target, true, false)) {
                        if(!collision_line(x, y, target.x, target.y, Obstacle, true, true)) {
                            bestTargetDist = point_distance(target.x,target.y,x,y);
                            if (object_is_ancestor(target.object_index, Character)) {
                                bestTarget = target.player;
                            } else if (target.object_index == Sentry) {
                                bestTarget = target;
                            }
                        }
                    }
                }
            }
        }
        ds_list_destroy(list);

        healTarget = bestTarget;
        readyToShoot=false;
        alarm[0]=1;
    }
    
    if(instance_exists(healTarget)) {
        if(healTarget.object_index == Player) {
            if(healTarget.object != -1) {
                if(point_distance(x,y,healTarget.object.x, healTarget.object.y)&lt;=maxHealDistance) {
                    if(collision_line(x,y, healTarget.object.x, healTarget.object.y, Obstacle, true, true)&lt;0) {
                        healedThisStep = true;
                        
                        if (healTarget.object.healer == -1)
                            healTarget.object.healer = ownerPlayer;
                        if (healTarget.object.burnDuration &gt; 0)
                            healTarget.object.burnDuration -= 1;
                        var healthGained;
                        healthGained = healAmount * calculateHealingFactor(healTarget.object.timeUnscathed);
                        healTarget.object.hp = min(healTarget.object.hp + healthGained, healTarget.object.maxHp);
                        hphealed += healthGained;
                        ownerPlayer.stats[HEALING] += healthGained;
                        ownerPlayer.roundStats[HEALING] += healthGained;
                        
                        
                        if(ubering == false &amp;&amp; uberCharge&lt;2000){
                            uberCharge+=1;
                            var setup;
                            setup = false;
                            if instance_exists(ControlPointSetupGate) {
                                if (ControlPointSetupGate.solid)
                                    setup = true;
                            }
                            if(healTarget.object.hp &lt; healTarget.object.maxHp or setup) uberCharge += 0.5;
                            if(healTarget.object.hp &lt; healTarget.object.maxHp/2 or setup) uberCharge += 1;
                            if(uberCharge &gt;= 2000) {
                                uberCharge = 2000;
                                if(global.isHost) {
                                    sendEventUberReady(ownerPlayer);
                                    doEventUberReady(ownerPlayer);
                                }
                            }
                        } else if(ubering == true){
                            if healTarget.object.ubered == 0 playsound(x,y,UberStartSnd);
                            healTarget.object.ubered = 1;
                            healTarget.object.alarm[2] = 3; 
                        }
                                                                   
                        if hphealed &gt;= HP_PER_POINT {
                            ownerPlayer.stats[POINTS] += 1;
                            ownerPlayer.roundStats[POINTS] += 1;
                            hphealed -= HP_PER_POINT;
                        }
    
                        if(alarm[3]&lt;=0) {
                            loopsoundstart(x,y,MedigunSnd);
                        } else {
                            loopsoundmaintain(x,y,MedigunSnd);
                        }
                        alarm[3]=2;
                    } else {
                        healTarget.object.healer = -1;
                        healTarget = noone;
                    }
                } else {
                    healTarget.object.healer = -1;
                    healTarget = noone;
                }
            } else {
                healTarget = noone;
            }
        } else if (healTarget.object_index == Sentry) {
            if(point_distance(x,y,healTarget.x, healTarget.y)&lt;=maxHealDistance) {
                if(collision_line(x,y, healTarget.x, healTarget.y, Obstacle, true, true)&lt;0) {
                    healedThisStep = true;
                    
                    if (healTarget.healer == -1)
                        healTarget.healer = ownerPlayer;
                    var healthGained;
                    healthGained = healAmount * calculateHealingFactor(healTarget.timeUnscathed);
                    healTarget.hp = min(healTarget.hp + healthGained, healTarget.maxHp);
                    hphealed += healthGained;
                    ownerPlayer.stats[HEALING] += healthGained;
                    ownerPlayer.roundStats[HEALING] += healthGained;
                                                               
                    if hphealed &gt;= HP_PER_POINT {
                        ownerPlayer.stats[POINTS] += 1;
                        ownerPlayer.roundStats[POINTS] += 1;
                        hphealed -= HP_PER_POINT;
                    }

                    if(alarm[3]&lt;=0) {
                        loopsoundstart(x,y,MedigunSnd);
                    } else {
                        loopsoundmaintain(x,y,MedigunSnd);
                    }
                    alarm[3]=2;
                } else {
                    healTarget.healer = -1;
                    healTarget = noone;
                }
            } else {
                healTarget.healer = -1;
                healTarget = noone;
            }
        }
    }
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
